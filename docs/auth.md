# Authentication & Session Security Specification

## Purpose and Scope

This document defines the end-to-end authentication and session lifecycle for clients using `discordSdk.commands.authenticate` and joining real-time rooms. It specifies:

- how authentication output is transferred to the backend and verified,
- server-issued session token format and lifecycle,
- required claims and replay protections,
- transport and origin security controls,
- room join authorization checks, and
- failure-mode and client recovery behavior.

The design assumes a browser client, a backend API, and a realtime gateway (WebSocket/WSS).

---

## 1) Discord SDK Authentication Handshake

### 1.1 Client-side flow

1. Client calls `discordSdk.commands.authenticate(...)`.
2. Client receives the Discord auth payload (`discord_auth_result`) from SDK.
3. Client immediately POSTs the payload to backend auth exchange endpoint:
   - `POST /api/auth/discord/exchange`
   - `Content-Type: application/json`
   - body includes the raw SDK output and a client nonce.

#### Request (example)

```json
{
  "provider": "discord_sdk",
  "sdk_auth": {
    "token": "<opaque-discord-token-or-signed-payload>",
    "expires_at": 1735689600,
    "application_id": "123456789012345678",
    "scope": "identify"
  },
  "client_nonce": "5b95f2d8-7d7f-4f03-8330-8d8f4a7f4f1d"
}
```

### 1.2 Backend verification requirements

On `/api/auth/discord/exchange`, server MUST:

1. **Validate schema** of incoming request (required fields, types, max sizes).
2. **Verify SDK output** against Discord expectations (via official SDK verification mechanism and/or Discord API validation of token identity, audience/app binding, expiry, and signature where applicable).
3. **Confirm audience/app binding**:
   - `application_id` (or equivalent claim) matches this deployment’s configured Discord app id.
4. **Confirm freshness**:
   - reject if SDK payload is already expired or outside allowed clock skew (recommended ±60s).
5. **Extract stable identity**:
   - canonical Discord user id (`discord_id`) from verified Discord response.
6. **Enforce anti-replay for exchange call**:
   - `client_nonce` MUST be unique per authentication attempt.
   - store nonce with short TTL (e.g., 5 minutes) and reject reuse.
7. **Issue server session token** if all checks pass.

If any verification step fails, return 401/400 with machine-readable error (see failure table).

---

## 2) Server-Issued Session Token

## 2.1 Token pair

Backend issues:

- **Access token** (short-lived, bearer): used for API calls and room join auth.
- **Refresh token** (longer-lived, rotating): used only at refresh endpoint.

### 2.2 Format

- Access token format: JWT (`alg` = `EdDSA` or `RS256`; `none` and symmetric-only dev shortcuts forbidden in production).
- Refresh token format: opaque random 256-bit+ identifier (preferred) or signed JWT with rotation id (`jti`).
- All tokens must be high-entropy and unguessable.

### 2.3 Required access-token claims

Access token MUST include:

- `sub`: canonical user subject (same value as `discord_id` or mapped internal user id).
- `discord_id`: verified Discord user id string.
- `iat`: issued-at (unix seconds).
- `exp`: expiry timestamp.
- `nonce`: session nonce generated by server per issued access token.
- `jti`: token id for targeted revocation/audit.
- `iss`: issuer identifier for this backend.
- `aud`: expected audience (`api` and/or `realtime`).

### 2.4 TTL policy

- Access token TTL: **15 minutes**.
- Refresh token TTL: **30 days** absolute max session age.
- Idle timeout for refresh session chain: **7 days** inactivity.

### 2.5 Refresh behavior

- Endpoint: `POST /api/auth/refresh`.
- Refresh token is sent in secure `HttpOnly` cookie (preferred) or request body for non-browser trusted clients.
- **Rotation required** on every refresh:
  1. verify presented refresh token is active and not revoked,
  2. mint new access token + new refresh token,
  3. atomically revoke old refresh token.
- Detect reuse of revoked/rotated refresh token as probable theft:
  - revoke entire session family,
  - require full re-authentication.

### 2.6 Revocation handling

Revocation can occur on logout, suspected compromise, moderation/admin action, or token reuse detection.

- Store revoked access `jti` until token expiry.
- Store refresh token status (`active`, `rotated`, `revoked`, `compromised`) in persistent store.
- On every protected request (API and room join), verify token signature/claims AND revocation status (or bounded-latency revocation cache).

---

## 3) Replay Mitigation

Replay resistance is mandatory at multiple layers:

1. **Exchange nonce**: `client_nonce` single-use, short TTL, per-auth attempt.
2. **Access token nonce + jti**: each issued token is unique; optionally enforce one-time join tickets for sensitive room joins.
3. **Short access TTL** reduces replay window.
4. **WSS join challenge (recommended)**:
   - server sends challenge nonce on socket auth,
   - client signs/echoes with current bearer context,
   - server validates challenge freshness.
5. **Refresh rotation**: replay of old refresh token triggers compromise workflow.

---

## 4) Transport and Security Controls

### 4.1 HTTPS/WSS requirements

- Production traffic MUST use HTTPS and WSS only.
- Reject plaintext `http://` and `ws://` except explicit local development mode.
- Enable HSTS (`max-age>=31536000; includeSubDomains`) on HTTPS origins.
- TLS 1.2+ required; prefer TLS 1.3.

### 4.2 CORS and origin policy

- Default deny-all CORS; allowlist explicit frontend origins only.
- `Access-Control-Allow-Origin` MUST be exact origin match, never `*` for credentialed requests.
- `Access-Control-Allow-Credentials: true` only when using cookie refresh flow.
- Validate `Origin` header for auth and refresh endpoints; reject unexpected origins.
- For WebSocket upgrades, verify `Origin` against same allowlist.

### 4.3 Token storage guidance

- Browser clients SHOULD keep access token in memory only (not localStorage).
- Refresh token SHOULD be stored in `Secure`, `HttpOnly`, `SameSite=Lax` or `Strict` cookie.
- If cross-site embedding is required, use `SameSite=None; Secure` and strict origin checks.

---

## 5) Room Join Authorization Checks

Room join path (HTTP preflight or WS event) MUST enforce:

1. Access token validity (signature, `exp`, `iat`, `iss`, `aud`, required claims).
2. Revocation status (`jti` not revoked).
3. Subject binding:
   - room permissions map to token subject (`discord_id` / `sub`).
4. Room-level ACL checks:
   - membership/role/ban status and room capacity constraints.
5. Optional anti-replay join ticket for privileged rooms:
   - short-lived (<=30s), single-use token bound to room id and `jti`.

On success, server returns join acceptance and effective permissions snapshot.

---

## 6) Failure Modes and Client Recovery

### 6.1 Error contract

All auth-related failures return:

```json
{
  "error": "token_expired",
  "message": "Access token expired",
  "recoverable": true,
  "retry_after_ms": 0
}
```

### 6.2 Standard failure behaviors

| Condition | Server behavior | Client behavior |
|---|---|---|
| Invalid Discord SDK payload | `401 invalid_discord_auth` | Prompt user to retry Discord login. |
| Exchange nonce reused | `409 nonce_reused` | Generate fresh nonce and restart auth exchange. |
| Access token expired | `401 token_expired` | Attempt single refresh; retry original request once. |
| Access token invalid signature/claims | `401 token_invalid` | Clear in-memory access token; perform full re-auth. |
| Refresh token expired/revoked | `401 refresh_invalid` | Clear session and force full login. |
| Refresh token reuse detected | `401 refresh_reuse_detected` + family revoked | Force logout on all tabs/devices if possible; full re-auth. |
| Revoked session on room join | Join denied (`403 session_revoked`) | Disconnect socket, clear session, re-authenticate. |
| Insufficient room permissions | `403 room_forbidden` | Show authorization error; do not auto-retry. |

### 6.3 Client retry and backoff rules

- Do not infinite-loop refresh attempts.
- At most one in-flight refresh request per client session.
- If refresh fails with non-recoverable error, clear auth state and return to login.
- Apply exponential backoff for transient `5xx` auth errors (e.g., 500ms, 1s, 2s, max 5s; max 3 tries).

### 6.4 Multi-tab/session consistency

- Broadcast logout/session-revoked events across tabs (e.g., `BroadcastChannel`).
- On receiving revoked event, all tabs clear tokens and redirect to login.

---

## 7) Observability and Auditing (Required)

- Log auth events with structured fields: `event`, `discord_id` (or hashed), `jti`, `ip_hash`, `user_agent_hash`, `result`, `reason`.
- Never log raw tokens or Discord secrets.
- Emit security alerts for:
  - repeated nonce reuse,
  - refresh reuse detection,
  - anomalous geo/IP changes within short period.

Retention and privacy handling should follow product compliance requirements.

---

## 8) Minimal Endpoint Contract Summary

- `POST /api/auth/discord/exchange` → verify Discord auth + issue access/refresh.
- `POST /api/auth/refresh` → rotate refresh + issue new access.
- `POST /api/auth/logout` → revoke current refresh family and optionally current access `jti`.
- `WS /realtime` (or equivalent) → require valid access token on connect and on room join.

This spec is normative for MVP authentication and session security behavior.
